# bit manipulation

## 位操作基础，用一张表描述位操作符的应用规则并详细解释。

位操作基础：



| &       |  与 | 两个位都为1时，结果才为1 |
| :--- | :--- | :--- |


| 符号 | 描述 | 运算规则 |
| :---: | :---: | :---: |
| & | 与 | 两个位同为1时，结果为1 |
| \| | 或 | 两个位都为0时，结果才为0 |
| ^ | 异或 | 两个位不同位，结果为1 |
| ~ | 取反 | 0变1，1变0 |
| &lt;&lt; | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0 |
| &gt;&gt; | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

重用技巧

```python
# 判断奇数偶数
def isOdd(n):
    return n & 1 == 0:

# 用位运算交换两个数
def swap(a, b):
    if a != b:
        a ^= b
        b ^= a
        a ^= b
    print(a)
    print(b)

# 交换符号，正数变成负数，负数变成正数
a = 123
neg_a = ~a + 1

# 求绝对值
int my_abs(int a) {
	int i = a >> 31;
	return i == 0 ? a : (~a + 1);
}

int my_abs(int a) {
	int i = a >> 31;
	return ((a ^ i) - i);
}
```

## 位操作与空间压缩，针对筛素数进行空间压缩。

```python
# 对整数的二进制数从右到左第n个二进制数制1
n = 10
j = 0
j |= 1 << n

# 判断整数的二进制数从右到左第n个二进制数是否是1
if j & (1 << n) == 1:
    print("n th bin is 1")
```

## 位操作的趣味应用，列举了位操作在高低位交换、二进制逆序、二进制中1的个数以及缺失的数字这4种趣味应用。

#### 高低位交换

给出一个16位的无符号整数。称这个二进制数的前8位为“高位”，后8位为“低位”。现在写一程序将它的高低位交换。例如，数34520用二进制表示为：

```text
  10000110 11011000
```

将它的高低位进行交换，我们得到了一个新的二进制数：

```text
  11011000 10000110
```

它即是十进制的55430。只要将x&gt;&gt;8与x&lt;&lt;8这两个数相或就可以得到11011000 10000110。

```cpp
#include <stdio.h>
template <class T>
void PrintfBinary(T a)
{
	int i;
	for (i = sizeof(a) * 8 - 1; i >= 0; --i)
	{
		if ((a >> i) & 1)
			putchar('1');
		else 
			putchar('0');
		if (i == 8)
			putchar(' ');
	}
	putchar('\n');
}
int main()
{
	printf("高低位交换 --- by MoreWindows( http://blog.csdn.net/MoreWindows )  ---\n\n");
 
	printf("交换前:    ");
	unsigned short a = 3344520;
	PrintfBinary(a);
 
	printf("交换后:    ");
	a = (a >> 8) | (a << 8);
	PrintfBinary(a);
	return 0;
}
```

#### 二进制逆序

第一步：每2位为一组，组内高低位交换

```text
   10 00 01 10  11 01 10 00
-->01 00 10 01 11 10 01 00
```



第二步：每4位为一组，组内高低位交换

```text
   0100 1001 1110 0100
-->0001 0110 1011 0001
```

第三步：每8位为一组，组内高低位交换

```text
   00010110 10110001
-->01100001 00011011
```

第四步：每16位为一组，组内高低位交换

```text
   01100001 00011011
-->00011011 01100001
```

对第一步，可以依次取出每2位作一组，再组内高低位交换，这样有点麻烦，下面介绍一种非常有技巧的方法。先分别取10000110 11011000的奇数位和偶数位，空位以下划线表示。

```text
  原 数    10000110 11011000

  奇数位 1_0_0_1_ 1_0_1_0_

  偶数位  _0_0_1_0 _1_1_0_0
```

将下划线用0填充，可得

```text
  原 数    10000110 11011000

  奇数位 10000010 10001000

  偶数位 00000100 01010000
```

再将奇数位右移一位，偶数位左移一位，此时将这两个数据相或即可以达到奇偶位上数据交换的效果了。

```text
  原数 10000110 11011000

  奇数位右移 01000001 01000100  

  偶数位左移 00001000 10100000

  相或得到 01001001 11100100
```

可以看出，结果完全达到了奇偶位的数据交换，再来考虑代码的实现——

```text
  取x的奇数位并将偶数位用0填充用代码实现就是x & 0xAAAA

  取x的偶数位并将奇数位用0填充用代码实现就是x & 0x5555
```

因此，第一步就用代码实现就是：

```text
   x = ((x & 0xAAAA) >> 1) | ((x & 0x5555) << 1);
```

```cpp
#include <stdio.h>
template <class T>
void PrintfBinary(T a)
{
	int i;
	for (i = sizeof(a) * 8 - 1; i >= 0; --i)
	{
		if ((a >> i) & 1)
			putchar('1');
		else 
			putchar('0');
		if (i == 8)
			putchar(' ');
	}
	putchar('\n');
}
int main()
{
	printf("二进制逆序 --- by MoreWindows( http://blog.csdn.net/MoreWindows )  ---\n\n");
 
	printf("逆序前:    ");
	unsigned short a = 34520;
	PrintfBinary(a);
 
	printf("逆序后:    ");	
	a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
	a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
	a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
	a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
	PrintfBinary(a);
}
```

#### 二进制中1的个数

统计二进制中1的个数可以直接移位再判断，当然像《编程之美》书中用循环移位计数或先打一个表再计算都可以。本文详细讲解一种高效的方法。以34520为例，可以通过下面四步来计算其二进制中1的个数二进制中1的个数。

第一步：每2位为一组，组内高低位相加

```text
     10 00 01 10 11 01 10 00
  -->01 00 01 01 10 01 01 00
```

第二步：每4位为一组，组内高低位相加

```text
  0100 0101 1001 0100
->0001 0010 0011 0001
```

第三步：每8位为一组，组内高低位相加

```text
   00010010 00110001
-->00000011 00000100
```

第四步：每16位为一组，组内高低位相加

```text
   00000011 00000100 
-->00000000 00000111
```

这样最后得到的00000000 00000111即7即34520二进制中1的个数。类似上文中对二进制逆序的做法不难实现的代码：

```python
a = ((a & 0xAAAA) >> 1) + (a & 0x5555)
a = ((a & 0xCCCC) >> 2) + (a & 0x3333);
a = ((a & 0xF0F0) >> 4) + (a & 0x0F0F);
a = ((a & 0xFF00) >> 8) + (a & 0x00FF);
```

#### 缺失的数字

1.自己与自己异或结果为0，2.异或满足交换律



#### 加减乘除运算符计算两个数字之和

```python
def add(a, b):
    # 计算每一位是否进位
    curry = a & b
    # 诸位相加但是不进位
    sum = a ^ b
    if curry != 0:
        return add(sum, curry << 1)
    return sum
```

#### 不用加减乘除运算符计算a = b \* 3

```python
def multi_three(b):
    return add(b << 1, b)
```

```text
作者：MoreWindows 
来源：CSDN 
原文：https://blog.csdn.net/morewindows/article/details/7354571 
版权声明：本文为博主原创文章，转载请附上博文链接！
```

